C51 COMPILER V9.60.7.0   MODEWORKINGFUNCTION                                               07/19/2024 17:31:56 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MODEWORKINGFUNCTION
OBJECT MODULE PLACED IN .\obj\ModeWorkingFunction.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE src\ModeWorkingFunction.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Driver
                    -s\inc;.\Drivers\src;.\src;.\inc) DEBUG OBJECTEXTEND PRINT(.\list\ModeWorkingFunction.lst) TABS(2) OBJECT(.\obj\ModeWorki
                    -ngFunction.obj)

line level    source

   1          #include "Global.h"
   2          /*--------------------------------------------------------------*/
   3          uint8_t CapChargeCounter;
   4          
   5          /*--------------------------------------------------------------*/
   6          const uint16_t RefVoltage[5] = 
   7          {
   8            2500,2700,2900,3100,3300,
   9          };
  10          /*----------------------------------------------------------------------------*/
  11          void BlinkCapChargeStart(void)
  12          {
  13   1      //  return;
  14   1        if(VinState == VinLow) 
  15   1        {
  16   2          ErrorState=VinVolError;
  17   2          IniWarningMode();
  18   2          return;
  19   2        }       
  20   1        else PwmDuty=PwmDutyStart;
  21   1        Pwm1Init();
  22   1        DelayCapChg=0;
  23   1      }
  24          /*----------------------------------------------------------------------------*/
  25          void IniWorkMode(void)
  26          {
  27   1        CapDisDisable;
  28   1        FireDisable;
  29   1        KeyValue = 0;
  30   1        CapChargeState=0; 
  31   1        ErrorState=0;
  32   1        FanTurnOn();
  33   1        CoolEnable;
  34   1        IniLedMode(LedWorking);
  35   1        MainState=WorkingMode;
  36   1      }
  37          /*--------------------------------------------------------------*/
  38          void ModeWorkingFunction(void)
  39          {
  40   1        if(KeyValue==KeyOnOffValue) {IniTurnOffMode();return;}
  41   1        if(DelayStandby>Delay5M)  {IniTurnOffMode();return;}
  42   1        if(bAutoState==1 && AutoDelay>30) {bAutoState=0;LedAutoState=0;}        
  43   1        if(VinState == VinLow)  { ErrorState=VinVolError;   IniWarningMode();return;}
  44   1        if(FanState == FanStateError) {   ErrorState=FanVError;  IniWarningMode();  return;}        
  45   1        if(NtcState != NtcTemNormal){ErrorState=NtcError; IniWarningMode(); return;}        
  46   1        ScanAutoKey();
  47   1        KeyAutoSet();
  48   1        CoolEnable;
  49   1        KeyGearAdjust();
  50   1        ConstantVoltageControl();
  51   1        if(MainState != WorkingMode) return;
  52   1        CheckCapChargeState();
  53   1        if(CapChargeState==1)
C51 COMPILER V9.60.7.0   MODEWORKINGFUNCTION                                               07/19/2024 17:31:56 PAGE 2   

  54   1        {
  55   2          if(bKeyTouchState==1)
  56   2          {
  57   3            if(bAutoState==1)
  58   3            {
  59   4              StopPwmOutput();
  60   4              LedSmartState=0;
  61   4              DisChargeCounter=0;
  62   4              DelayStandby=0;
  63   4              AutoDelay=0;
  64   4              StateDelay=0;
  65   4              DelayDisCHG=0;
  66   4              FireEnable;
  67   4              MainState=FireingMode;
  68   4              return;
  69   4            }
  70   3            else
  71   3            {
  72   4              MainState=WaitingFireMode;
  73   4              LedSmartState=1;
  74   4              LedAutoState=0;
  75   4              LedDelay=0;
  76   4              KeyValue = 0;
  77   4              return;
  78   4            }
  79   3          }
  80   2          else
  81   2          {
  82   3            LedSmartState=0;
  83   3          }
  84   2        }
  85   1        else {LedSmartState=0;}
  86   1      }
  87          /*----------------------------------------------------------------------------*/
  88          void WaitForFire(void)
  89          {
  90   1        if(KeyValue==KeyOnOffValue) {IniTurnOffMode();return;}
  91   1        if(DelayStandby>Delay5M)  {IniTurnOffMode();return;}
  92   1        if(VinState == VinLow) {ErrorState=VinVolError; IniWarningMode(); return; }       
  93   1        if(FanState == FanStateError){ ErrorState=FanVError; IniWarningMode();return;}        
  94   1        if(NtcState != NtcTemNormal){ErrorState=NtcError; IniWarningMode(); return; }       
  95   1        ScanAutoKey();
  96   1        KeyAutoSet();
  97   1        CoolEnable;
  98   1        KeyGearAdjust();
  99   1        ConstantVoltageControl();
 100   1        if(MainState != WaitingFireMode) return;
 101   1        CheckCapChargeState();
 102   1        if(MainState!=WaitingFireMode) return;
 103   1        if(bKeyTouchState==0)
 104   1        {
 105   2          MainState=WorkingMode;
 106   2          LedSmartState=0;
 107   2          KeyValue = 0;
 108   2          return;
 109   2        }
 110   1        if(ReadFireKey()==KeyFire)
 111   1        {
 112   2          bKeyTouchState=0;
 113   2          KeyValue = 0;
 114   2          StopPwmOutput();
 115   2          FireEnable;
C51 COMPILER V9.60.7.0   MODEWORKINGFUNCTION                                               07/19/2024 17:31:56 PAGE 3   

 116   2          DisChargeCounter=0;
 117   2          DelayStandby=0;
 118   2          StateDelay=0;
 119   2          DelayDisCHG=0;        
 120   2          bKeyTouchState=0;
 121   2          MainState=FireingMode;
 122   2          return;
 123   2        }
 124   1      }
 125          /*----------------------------------------------------------------------------*/
 126          void FireingCheck(void)
 127          {
 128   1        if(KeyValue==KeyOnOffValue) {IniTurnOffMode();return;}
 129   1        if(DelayStandby>Delay5M)  {IniTurnOffMode();return;}
 130   1        ScanAutoKey();
 131   1        KeyAutoSet();
 132   1        CoolEnable;
 133   1        KeyGearAdjust();
 134   1        ReadVoutVoltage(5);
 135   1        if(VoutVoltageValue < ReBoostVol)
 136   1        {
 137   2            FireCounter++;
 138   2            if(FireCounter>FireTimes)// || FireCounter==0)
 139   2            {
 140   3              FireCounter=0;//FireTimes;
 141   3            }
 142   2            IniWorkMode();
 143   2            BlinkCapChargeStart();
 144   2            DisChgErrorCnt=0;
 145   2            KeyValue = 0;
 146   2            return;
 147   2        }
 148   1        else
 149   1        {
 150   2          DisChargeCounter=0;
 151   2          if(DelayDisCHG>25)
 152   2          {
 153   3            DelayDisCHG=0;
 154   3            if(bDisState==1) {bDisState=0;FireDisable;}
 155   3            else {bDisState=1;FireEnable;}
 156   3          }
 157   2        }
 158   1        if(MainState!=FireingMode) return;
 159   1        if(StateDelay>5000)
 160   1        {
 161   2          ++DisChgErrorCnt;
 162   2          if(DisChgErrorCnt>=5)
 163   2          {
 164   3            ErrorState=LeakError;
 165   3            IniWarningMode();
 166   3          }
 167   2          else
 168   2          {
 169   3            IniWorkMode();
 170   3            BlinkCapChargeStart();
 171   3            KeyValue = 0;
 172   3          }     
 173   2        } 
 174   1      }
 175          /*----------------------------------------------------------------------------*/
 176          void CheckCapChargeState(void)
 177          {
C51 COMPILER V9.60.7.0   MODEWORKINGFUNCTION                                               07/19/2024 17:31:56 PAGE 4   

 178   1        uint16_t RefOutVoltage,RefVolMin,RefVolMax;
 179   1        uint8_t i;
 180   1        RefOutVoltage=RefVoltage[GearState];
 181   1        //RefOutVoltage=RefOutVoltage;
 182   1        RefVolMin=RefOutVoltage-30;
 183   1        RefVolMax=RefOutVoltage+30;
 184   1        if(MainState==AgingMode) i=5;
 185   1        else i=1;
 186   1        if(VoutVoltageValue>=RefVolMin)
 187   1        {
 188   2          if(CapChargeState==1) CapChargeCounter=0;
 189   2          if(++CapChargeCounter>=i)
 190   2          {
 191   3            CapChargeState=1;
 192   3            CapChargeCounter=0;
 193   3          }
 194   2        }
 195   1        else
 196   1        {
 197   2          if(MainState==AgingMode)
 198   2          {
 199   3            if(CapChargeState==0) CapChargeCounter=0;
 200   3            if(++CapChargeCounter>=i)
 201   3            {
 202   4              CapChargeState=0;
 203   4              CapChargeCounter=0;
 204   4            }
 205   3          }
 206   2          else
 207   2          {
 208   3            if(DelayCapChg>=3500)
 209   3            {
 210   4              CapChargeState=1;
 211   4              CapChargeCounter=0;
 212   4            }
 213   3            else
 214   3            {
 215   4              CapChargeState=0;
 216   4              CapChargeCounter=0;
 217   4            }
 218   3          }
 219   2        }
 220   1      }
 221          /*----------------------------------------------------------------------------*/
 222          /*----------------------------------------------------------------------------*/
 223          void ConstantVoltageControl(void)
 224          {
 225   1        uint16_t RefOutVoltage;
 226   1        uint16_t ILimtDown,ILimtUp;
 227   1        uint16_t TempDutyMax;
 228   1      
 229   1        ReadVoutVoltage(5);
 230   1        ReadVinCurrent(5);
 231   1        RefOutVoltage=RefVoltage[GearState];
 232   1        
 233   1        if(VinState == VinLow) 
 234   1        {
 235   2          ErrorState=VinVolError;
 236   2          IniWarningMode();
 237   2          return;
 238   2        }       
 239   1        else 
C51 COMPILER V9.60.7.0   MODEWORKINGFUNCTION                                               07/19/2024 17:31:56 PAGE 5   

 240   1        { ILimtDown=122;ILimtUp=125;TempDutyMax=PwmDutyMax;}//ILimtDown=122;ILimtUp=125;
 241   1        
 242   1        if((VoutVoltageValue < (RefOutVoltage-10)) && (VinCurrentValue<ILimtDown))
 243   1        {   
 244   2          if(PwmDuty > TempDutyMax) PwmDuty=TempDutyMax;
 245   2          else
 246   2          {
 247   3            PwmDuty++;
 248   3            PwmDuty++;
 249   3            Pwm1SetDuty(PwmDuty);
 250   3          }
 251   2        }
 252   1        else if((VoutVoltageValue > (RefOutVoltage+10)) || (VinCurrentValue>ILimtUp))
 253   1        {
 254   2          if(PwmDuty > TempDutyMax) PwmDuty=TempDutyMax;
 255   2            if(PwmDuty <= PwmDutyMin) {PwmDuty=PwmDutyMin;PWMDisable;}
 256   2            else
 257   2            {
 258   3              if(PwmDuty>PwmDutyMin) { PwmDuty--;Pwm1SetDuty(PwmDuty);}
 259   3              else {PwmDuty=PwmDutyMin;PWMDisable;}       
 260   3            }
 261   2        }
 262   1      }
 263          /*----------------------------------------------------------------------------*/
 264          
 265          /*--------------------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1204    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     11      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
